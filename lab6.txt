LING 567, Lab 6 Note File
Antariksh Bothale (author), Andrew Baer
Language: Marathi (mar)

Yes / No questions
----------------------------------

1. A descriptive statement of the facts of your language. 

Propositions are converted into Yes / No questions by adding the particle kaa at the end of the sentence (quite similar to Japanese). The particle turns declarative sentences into interrogatives. The declarative sentence is not changed in any way beyond the addition of the question particle. The first example shows the grammatical question "did he come back yesterday?"and the second example shows the declarative sentence "he came back yesterday". The only difference between the two is the question particle. The third example shows that the question particle can only occur at the end of the sentence in positive yes/no questions. Intonation can also be used to convert a sentence into a question. Kaa is allowed to occur only at the end of the sentence. In other positions it means "Why". 

2. Illustrative IGT examples from your testsuite.

Source: {a:7}
Vetted: {t}
Judgment: g
Phenomena: {q}
to kaal parat aalaa kaa
to kaal parat aa-l-aa kaa
he yesterday back came-PST-3.S.M Q
Did he come back yesterday?

Source: {author}
Vetted: {t}
Judgment: g
Phenomena: {wo}
to kaal parat aalaa
to kaal parat aa-l-aa
he yesterday back came-PST-3.S.M 
He came back yesterday

Source: {author}
Vetted: {t}
Judgment: u
Phenomena: {q}
kaa to kaal parat aalaa
kaato kaal parat aa-l-aa
Q he yesterday back came-PST-3.S.M 
Did he come back yesterday?

Source: {author}
Vetted: {t}
Judgment: g
Phenomena: {q, wo}
to kaal parat kaa aalaa 
to kaal parat kaa aa-l-aa
he yesterday back why came-PST-3.S.M 
Why did he come back yesterday?

3. A statement of how you implemented the phenomenon, in terms of types you added/modified and particular tdl constraints. That is, I want to see actual tdl snippets with prose descriptions around them.

The setup provided by the customatization system was working fine but it became inadequate later when we worked on the embedded clauses and such. This was tweaked a bit to make way for the rest of the machinery. Here is what we have right now.


complementizer-lex-item := raise-sem-lex-item & basic-one-arg &
  [ SYNSEM.LOCAL.CAT [ HEAD comp &
                            [ MOD < > ],
                       VAL [ SPR < >,
                             SUBJ < >,
                             COMPS < #comp > ]],
    ARG-ST < #comp &
             [ LOCAL.CAT [ HEAD verb,
                           VAL [ SUBJ < >,
                                 COMPS < > ] ] ] > ].

mc_plus_complementizer-lex-item := complementizer-lex-item & 
  [ SYNSEM.LOCAL.CAT.MC +].

mc_minus_complementizer-lex-item := complementizer-lex-item & 
  [ SYNSEM.LOCAL.CAT.MC -].

; Subtype for question particles. Constrains SF to ques.

qpart-lex-item := mc_plus_complementizer-lex-item &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.SF ques,
                   CAT [VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM finite,
			HEAD.H-INIT -]] ].

4. If the analysis is not (fully) working, a description of the problems you are encountering. 

Works fine for main clauses but does not work properly for embedded clauses. The problem is that we are constraining the MC to + for "kaa" because we do not want it to spuriously behave as a traditional complementizer. Since MC is + it does not combine at the embedded level. If we constrain MC to -, it will combine at the embedded level but simple questions won't parse as the root needs to be MC +.


Embedded clauses and questions.
--------------------------------------------

1. A descriptive statement of the facts of your language.

Embedded clauses are marked by the complementizers "kii" and "asa" preceding and following the embedded clause respectively. "kii" is used in both declarative and interrogative clauses. "asa" is used as a quotative marker. Note here that a kii headed CP can't precede the matrix verb and an asa headed CP can't follow the matrix verb. Both kii and asa are obligatory (There is a bit of a mess around whether they can be omitted in casual speech, but we decided not to get into that quagmire).

Certain verbs also frequently appear before embedded clauses. The verbs can either "invite" declarative or interrogative clauses. In our test suite, the declarative verb is "mhann" (to tell) and the interrogative verb is "vicar" (to ask).  

2. Illustrative IGT examples from your testsuite.

#147
Source: {author}
Vetted: {t}
Judgment: g
Phenomena: {emb-q}
tuu zhopto kaa asa polis malaa vicaarto 
tuu zhop-t-o kaa asa polis malaa vicaar-t-o
you sleep-PRES-2.S.M Q QUOT police I.DAT ask-PRES-3.S.M
"Do you sleep?" the police asks me.

#145
Source: {author}
Vetted: {t}
Judgment: g
Phenomena: {emb-q}
polis malaa vicaarto kii mii zhopto kaa
polis malaa vicaar-t-o kii mii zhop-t-o kaa
police I.DAT ask-PRES-3.S.M that I sleep-PRES-1.S.M Q
(The) police asks me if I sleep

#143
Source: {author}
Vetted: {t}
Judgment: g
Phenomena: {emb-d}
ravi miitaalaa mhannte kii tii dzunii gaadii aalii
ravi miitaa-laa mhann-t-o kii tii dzun-ii gaadii aa-l-ii
Ravi miitaa-DAT say-PRES-3.S.M that that old-3.S.F train come-PAST-3.S.F
Ravi says to Meeta that that old train came

#144
Source: {author}
Vetted: {t}
Judgment: u
Phenomena: {emb-d}
ravi miitaalaa mhannte tii dzunii gaadii aalii
ravi miitaa-laa mhann-t-e tii dzun-ii gaadii aa-l-ii
Ravi miitaa-DAT say-PRES-3.S.F that old-3.S.F train come-PAST-3.S.F
Ravi says to Meeta that that old train came

Source: {author}
Vetted: {t}
Judgment: u
Phenomena: {emb-d}
ravi kii tii dzunii gaadii aalii miitaalaa mhannte 
ravi kii tii dzun-ii gaadii aa-l-ii miitaa-laa mhann-t-e
Ravi that that old-3.S.F train come-PAST-3.S.F miitaa-DAT say-PRES-3.S.F
Ravi says to Meeta that that old train came

Source: {author}
Vetted: {t}
Judgment: u
Phenomena: {emb-d}
ravi miitaalaa mhannte tii dzunii gaadii asa
ravi miitaa-laa mhann-t-e tii dzun-ii gaadii aa-l-ii asa
Ravi that old-3.S.F train come-PAST-3.S.F miitaa-DAT say-PRES-3.S.F QUOT
Ravi says to Meeta that that old train came


The final two examples are ungrammatical because a kii complementizer cannot appear before the verb of the main clause. 

3. A statement of how you implemented the phenomenon, in terms of types you added/modified and particular tdl constraints. That is, I want to see actual tdl snippets with prose descriptions around them.

Our head-complement and complement-head rules needed to handle the following cases.

HEAD-COMP:
V CP [kii headed]
C S [kii]

COMP-HEAD:
S C [asa]
S C [kaa]
CP V [asa headed]

We added the features H-INIT and C-INIT on HEAD to constrain whether or not a complementizer can appear before the head of the phrase, and whether the whole CP created by that complementizer can appear after or before the matrix verb.

We already had complementizer-lex-item that inherits from raise-sem-lex-item and basic-one-arg. 

complementizer-lex-item := raise-sem-lex-item & basic-one-arg &
  [ SYNSEM.LOCAL.CAT [ HEAD comp &
                            [ MOD < > ],
                       VAL [ SPR < >,
                             SUBJ < >,
                             COMPS < #comp > ]],
    ARG-ST < #comp &
             [ LOCAL.CAT [ HEAD verb,
                           VAL [ SUBJ < >,
                                 COMPS < > ] ] ] > ].

We also used the feature MC +/- to constrain the marking of embedded clauses. Because complementizers in Marathi always mark embedded clauses, they are both marked as MC-. 

mc_plus_complementizer-lex-item := complementizer-lex-item & 
  [ SYNSEM.LOCAL.CAT.MC +].

mc_minus_complementizer-lex-item := complementizer-lex-item & 
  [ SYNSEM.LOCAL.CAT.MC -].

; Subtypes for kaa and asa
init_plus_complementizer-lex-item := mc_minus_complementizer-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD [ H-INIT +, 
			    C-INIT - ] ].

init_minus_complementizer-lex-item := mc_minus_complementizer-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD [H-INIT -,
			   C-INIT + ]].

; Subtype for question particles. Constrains SF to ques.

qpart-lex-item := mc_plus_complementizer-lex-item &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.SF ques,
                   CAT [VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM finite,
			HEAD.H-INIT -]] ].

kii := init_plus_complementizer-lex-item & 
  [ STEM < "kii" > ].

asa := init_minus_complementizer-lex-item & 
  [ STEM < "asa" > ].

The question particle "kaa", treated as a complementizer in our grammar, is marked as INIT - because it occurs as the complement of a head-comp phrase. 

qpart-lex-item := mc_plus_complementizer-lex-item &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX.SF ques,
                   CAT [VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM finite,
			HEAD.INIT -]] ]. 

We also modified the head-comp and comp-head rules to constrain the H-INIT and C-INIT values of their daughters. head-comp has also been constrained to head +vc to avoid any other accidental phrase formation.

comp-head-phrase := basic-head-1st-comp-phrase & head-final &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.H-INIT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.C-INIT + ].

head-comp-phrase := basic-head-1st-comp-phrase & head-initial & 
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.H-INIT +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT [HEAD +vc & [C-INIT - ]]].

We introduced a new verb type, embedded_clause_inviting_verb-lex, for the verbs that take embedded clauses as complements. It specifies the one item on its COMPS list as an element that is HEAD comp and MC -. It inherits from main-verb-lex and clausal-second-arg-trans-lex-item. It constrains the case of its subj to be erg+nom. Also, it should be pointed out here that this verb can't take another additional complement (such as He told "me" that ...). Since these go BEFORE the verb in Marathi while the clausal complements go AFTER, it's a bit complicated, and we will tackle it in the "extras" of the next lab.

embedded_clause_inviting_verb-lex := main-verb-lex & clausal-second-arg-trans-lex-item &
  [ ARG-ST < synsem, #arg >,
    SYNSEM.LOCAL.CAT.VAL [ SPR < >,
			   COMPS < #arg & 
				   [ LOCAL [ CAT [ HEAD comp,
						   VAL [ SPR < >,
							 COMPS < > ],
						   MC -],
					     CONT.HOOK.INDEX.SF prop-or-ques]] >,
			   SUBJ.FIRST.LOCAL.CAT.HEAD.CASE erg+nom ]].

Two subtypes of embedded_clause_inviting_verb-lex were introduced, constrained by the feature SF to be prop or ques. Verbs that inherit from emb-d-inviting_verb-lex take embedded declaratives as complements. Verbs that inherit from emb-q-inviting_verb-lex take embedded questions as complements. 

emb-d-inviting_verb-lex := embedded_clause_inviting_verb-lex & 
  [SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX.SF prop] > ].
			
emb-q-inviting_verb-lex := embedded_clause_inviting_verb-lex & 
  [SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX.SF ques] > ].

vicaar := emb-q-inviting_verb-lex &
  [ STEM < "vicaar" >,
    SYNSEM.LKEYS.KEYREL.PRED "_ask_v_rel" ].

mhann :=  emb-d-inviting_verb-lex & 
  [ STEM < "mhann" >,
    SYNSEM.LKEYS.KEYREL.PRED "_tell_v_rel" ].


4. If the analysis is not (fully) working, a description of the problems you are encountering. 

To the best of our knowledge, this analysis is working. As discussed above, questioning the embedded clause is not working. When we do it, it parses but actually questions the matrix clauses, which isn't grammatical in marathi (for kii clauses).


Non-verbal predicates
------------------------------------------
1. A descriptive statement of the facts of your language.

Marathi has a copula "as (be)" that allows for noun, adjective and adverb predicates. The unmarked word order is subject-complement-copula. It is slightly irregular, as the "to be" verb is cursed to be, and has varying forms. We illustrate our examples using "aahe" which is PRES-3.S.M form

The nominative case is used on the subject and on the NP predicate. 

Adjectival predicates occur as the complement of "as". A nominative noun is the subject. Depending on the adjective, it has to (if it's of the inflectional type) agree in gender and pernum with the noun. 

Likewise, locational PPs are actually just nouns in the locative case. 

2. Illustrative IGT examples from your testsuite.


#149
Source: {author}
Vetted: {t}
Judgment: g
Phenomena: {cop}
tii gaadii dzunii aahe
tii gaadii dzun-ii aa-he
that train.S.F old-S.F be-3.S.F
That train is old
(adjectival)

#148
Source: {author}
Vetted: {t}
Judgment: g
Phenomena: {cop}
to tsor aahe
to tsor aa-he
he thief be-3.S.M
He is (a) thief 
(noun)

Source: {author}
Vetted: {t}
Judgment: g
Phenomena: {cop}
to bhaarataat aahe
to bhaarat-aat aahe
he india-LOC be.3.S.M
He is in India
(PP)


3. A statement of how you implemented the phenomenon, in terms of types you added/modified and particular tdl constraints. That is, I want to see actual tdl snippets with prose descriptions around them.

We defined a super-type for copulas. 

copula-verb-lex-supertype := non-mod-lex-item & 
  [ SYNSEM.LOCAL.CAT [ HEAD verb,
		       VAL [ SUBJ.FIRST.LOCAL.CAT.HEAD.CASE nom ]],
    INFLECTED [ VERB_TENSE_ASPECT-FLAG +,
                VERB_GENDER_PERNUM-FLAG +] ].

The copula that takes APs and PPs is subclassed from that super-type.

copula-verb-lex := copula-verb-lex-supertype & trans-first-arg-raising-lex-item-2 &
  [ SYNSEM.LOCAL [ CAT.VAL [ SUBJ < #subj >,
                             COMPS < #comps >,
                             SPR < >,
                             SPEC < > ],
                   CONT.HOOK.XARG #xarg ],
    ARG-ST < #subj &
             [ LOCAL [ CONT.HOOK.INDEX #xarg,
                       CAT [ VAL [ SPR < >,
                                   COMPS < > ],
                             HEAD noun ] ] ],
             #comps &
             [ LOCAL.CAT [ VAL [ COMPS < > ],
                           HEAD +jp ] ] > ].

This subclasses the transitive verb lexeme and makes its inflection flags + so that the verb does not need to inflect. 

copula-transitive-verb-lex := main-verb-lex & transitive-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < #comps >,
    ARG-ST < [ LOCAL.CAT.HEAD noun ],
             #comps &
             [ LOCAL.CAT [ VAL [ SPR < >,
                                 COMPS < > ],
                           HEAD noun ] ] >,
    INFLECTED [ VERB_TENSE_ASPECT-FLAG +,
                VERB_GENDER_PERNUM-FLAG + ] ].


Constrains the SUBJ and COMPS to be nominative.

noun-copula-verb-lex := copula-transitive-verb-lex & 
  [ SYNSEM.LOCAL [CAT.VAL [COMPS.FIRST.LOCAL.CAT.HEAD.CASE nom,
			  SUBJ.FIRST.LOCAL.CAT.HEAD.CASE nom ]]].


In order to make the PPs work, we wrote a non-branching non-headed rule that takes a locative NP and forms a PP over it.

locative-pp-phrase := unary-phrase &
  [ SYNSEM [LOCAL.CAT [ HEAD adp & [MOD <[SYNSEM.LOCAL.CAT.HEAD verb] >],
		       VAL [ COMPS < >,
			     SUBJ < >, 
			     SPR < > ] ],
	    LKEYS.KEYREL.PRED "_loc_p_rel" ],
    
    C-CONT [ HOOK [ LTOP #ltop,
		    INDEX #index,
		    XARG #xarg ],
	     RELS <! arg12-ev-relation &
		   [ PRED "_be_v_id_rel",
		     LBL #ltop,
		     ARG0 #index,
		     ARG1 #xarg,
		     ARG2 #dtr ] !>,
	     HCONS <! !>  ],
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD noun & [CASE loc],
				  VAL.SPR < > ],
			    CONT.HOOK [ INDEX #dtr ]]] > ].


4. If the analysis is not (fully) working, a description of the problems you are encountering. 

The MRS for all the predicates are correct. But in case of the locative_pred (PPs), we can't get the grammar to generate. I imagine it is because there is no lexical entry that has this predication, but since the PP in this case isn't exactly formed from a lexical postposition but rather from a locative noun, I am not sure how to fix this.

Also, we have only one entry for "to be" right now as a proof of concept. We will flesh out all the TENSE-PER-NUM-GEND combos soon.


Anything else we fixed. 
------------------------

Plenty of stuff, actually. Two major breakthroughs have been that the Ergative case system with its idiosyncratic verb agreement properties has now been sorted out and that determiner CASE agreement is sorted out.




itsdb
-----

We get 52.3% (45/86) Coverage, which is an increase over the previous test suite. (39/86). Overgeneration has reduced too. We have 5 to the previous value of 7. Number of parses have reduced for quite a few sentences. More importantly, the parses are more accurate now, in the sense that the grammar and lexicon background is actually enforcing that the agreement etc matches up (earlier, spurious sentences would parse because determiner agreement wasn't set up).

The baseline comparison is as follows:
			(G)old				New
	Lexical	| Analyses | In | Out || Lexical | Analyses | In | Out 
Total	3.05	   4.98	    45.9  8.7     3.06       2.72    52.3 6.3
